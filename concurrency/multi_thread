
可重入:一个函数可以同时被调用,不会有影响
线程安全:一个函数可以被多线程同时调用,不会有影响.

可重入>线程安全,需要比线程安全更强的条件.

malloc是线程安全的,是因为它加了线程锁保护了其中的临界区,但是它不是可重入的,因为里面有静态变量,如果同时被进入,那么就会发生错乱.
大致上,一个函数如果使用了静态变量,那么就是不可重入的.

摘自:
http://blog.csdn.net/aniao/article/details/5758021

可重入：概念基本没有比较正式的完整解释，但是它比线程安全要求更严格。根据经验，所谓“重入”，常见的情况是，程序执行到某个函数foo()时，收到信号，于是暂停目前正在执行的函数，转到信号处理函数，而这个信号处理函数的执行过程中，又恰恰也会进入到刚刚执行的函数foo()，这样便发生了所谓的重入。此时如果foo()能够正确的运行，而且处理完成后，之前暂停的foo()也能够正确运行，则说明它是可重入的。


要确保函数可重入，需满足一下几个条件：
1、不在函数内部使用静态或全局数据
2、不返回静态或全局数据，所有数据都由函数的调用者提供。
3、使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。
4、不调用不可重入函数。

摘自:
http://blog.csdn.net/hairetz/article/details/4281931


一个线程安全的类应该满足以下三个条件:
*   多个线程同时访问，其表现出正常的行为
*   无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织.
*   调用端代码无需额外的同步或其他协调动作.
p4

我们不必担心系统调用的安全性, 因为系统调用对用户态程序来说是原子的.
p86 这句话怎么理解.

编写线程安全程序的一个难点在于线程安全不是可组合的.
p87


exit不是线程安全的
exit函数在c++中除了终止线程, 还会析构全局对象和一构造完的函数静态对象.
这里就有潜在死锁的可能.
p94 4.4.2


多线程与IO

一般原则:

每个文件描述符, 只有一个线程操作, 从而轻松解决消息收发的顺序性问题,
也避免了关闭文件描述符的各种race condition.

一个线程可以操作多个文件描述符, 但那一个线程不能操作别的线程拥有的描述符.

例外:

对于磁盘文件, 在必要时多个线程可以同时调用pread/pwirte来读写同一个文件.

都与UDP, 协议本身保证消息的原子性,
在适当的情况下(比如消息之间相互独立)可以用多个线程读写统一个UDP文件描述符.


防止fd串话

接受了一个tcp连接, fd = fdi,
如果读了请求, 做处理, 关闭fd.
再接受新的连接, 会造成fd重用.
gigi

怎么区分, fd呢.
1.  全局状态, 判断fd是否处于空白状态.
    关闭的时候，要清空状态.
2.  通过RAII来使用, 不关, 直到不用为止.
    当对象释放的的时候, 再关闭fd, 可以防止串话.
    chenshuo, 说的好像不这么做就没办法做似的, 那c语言怎么高效实现的....
p4.7


怎么觉得不是那么回事呢?
你看，如果一个fd只在一个线程里访问, 怎么会出现串话呢?
关闭和使用都是在一个线程内, 没有全局锁神马的.
我关的，我肯定知道这个fd用不了是不是?
或者当另外一个新的fd闯过来的时候, 我们也可以直到这是一个新的fd，对不?
清空本次或者上次使用痕迹即可哈~~~

批判吸收之...



fork与多线程

假设这么一个环境，在 fork 之前，有一个子线程 lock 了某个锁，获得了对锁的所有权。
fork 以后，在子进程中，所有的额外线程都人间蒸发了。
而锁却被正常复制了，在子进程看来，这个锁没有主人，所以没有任何人可以对它解锁。

一般的惯例，多线程程序 fork 前，应该由发起 fork 的线程 lock 所有子进程可能用到的锁，fork 后，把它们一一 unlock 。当然，这样的做法就隐含了锁的次序。如果次序和平时不同，那么就会死锁。
这个任务可以由pthread_at_fork来完成
http://blog.codingnow.com/2011/01/fork_multi_thread.html

坑啊，到处都是坑.
http://blog.csdn.net/hanchaoman/article/details/5685582

so.fork之后还是立即去调用exec吧...


多线程与信号
在多线程程序中, 不要使用signal.
p104.

这个原因，我不是很明白...
状态不佳，过后再看.

Linux 多线程应用中如何编写安全的信号处理函数 
http://www.ibm.com/developerworks/cn/linux/l-cn-signalsec/


多线程与linux 新增系统调用启示

eventfd
singalfd
timerfd
可以把事件,信号, 定时纳入select, pool, epoll模型.


本文中注有页码的部分, 是linux多线程服务器端编程: 使用muduo c++网络库上的.
